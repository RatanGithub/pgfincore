Features
=========

PgFincore is a set of functions to manage blocks in memory.
Each Table or Index is truncated in segment of (usually) 1GB, and each segment
is truncated in block in filesystem.

Those tools let you record which disk block from a table are in the buffer cache 
of the operating system, and write the result to a file.
Then using this file, it is possible to restore the buffer cache state for each 
block of the relation.

It is usefull on server (not postgresql, but hardware ) restart : it fill the 
buffer cache with the blocks that were in buffer cache *before* shutdown. So 
first executed queries in postgresql are not slow down because of extra I/O.

Each functions are call with a table or index name (or oid) as a parameter and 
walk each segment of the relation.

Pgmincore will return information on the number of blocks per segment wich are
actually in the buffer cache of the operating system. It also provide the
amount of contigous blocks in memory. (a big number is probably the 
representation of a heavy random scan segment, and a low number a seqscan or a
small segment)
The function pgmincore_snapshot push this information to a file.

Pgfadv_willneed_snapshot is then used to reload blocks in the buffer cache of 
the operating system.

All other functions are used to set a posix_fadvise flag on the entire relation 
(each segment). The more usefull are probably WILLNEED and DONTNEED wich push
and pop from buffer cache respectively.

man 2 posix_fadvise for more information. 

Install
=======

export USE_PGXS=1 ; make clean ; make
su ; export USE_PGXS=1 ; make install

Create the functions from the sql script (it should be in your contrib directory)
psql mydb -f pgfincore.sql

Debug
=====

set client_min_messages TO debug5;

Use it
======

cedric=# select * from pgfincore('test');
 relname |      relpath       | block_disk | block_mem | group_mem
---------+--------------------+------------+-----------+-----------
 test    | base/16987/26245   |     262144 |         0 |         0
 test    | base/16987/26245.1 |       8090 |         0 |         0
cedric=# select * from test limit 10000;
cedric=# select * from pgfincore('test');
 relname |      relpath       | block_disk | block_mem | group_mem
---------+--------------------+------------+-----------+-----------
 test    | base/16987/26245   |     262144 |       426 |         1
 test    | base/16987/26245.1 |       8090 |         0 |         0

Or more fun :

cedric=# with recursive pgclass (reloid,reltoastrelid) as (
 select oid, reltoastrelid from pg_class where relname ='largetable'
union all
 select t.oid,t.reltoastrelid from pgclass p, pg_class t
 where p.reltoastrelid = t.oid
) select pgfincore(pgclass.reloid) from pgclass;
                pgfincore
-----------------------------------------
 (largetable,base/16987/83603,2,0,0)
 (pg_toast_83603,base/16987/83606,0,0,0)



Enjoy ;)


cedric=# select * from  pgfincore ('a');
     relpath      | block_disk | block_mem | group_mem
------------------+------------+-----------+-----------
 base/16385/16390 |          2 |         2 |         1
(1 ligne)

cedric=# select * from pgfadv_dontneed ('a');
     relpath      | block_disk | block_size
------------------+------------+------------
 base/16385/16390 |          2 |       4096
(1 ligne)

cedric=# select * from  pgfincore ('a');
     relpath      | block_disk | block_mem | group_mem
------------------+------------+-----------+-----------
 base/16385/16390 |          2 |         0 |         0
(1 ligne)

cedric=# select * from pgfadv_willneed ('a');
     relpath      | block_disk | block_size
------------------+------------+------------
 base/16385/16390 |          2 |       4096
(1 ligne)

cedric=# select * from  pgfincore ('a');
     relpath      | block_disk | block_mem | group_mem
------------------+------------+-----------+-----------
 base/16385/16390 |          2 |         2 |         1
(1 ligne)


